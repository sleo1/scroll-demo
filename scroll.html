<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mobil 300×534 – autoscroll fix + overrides</title>
<style>
  :root{
    --phone-w: 300px;
    --phone-h: 534px;     /* 300 * (667/375) */
    --screen-lr: 8px;
    --screen-top: 20px;
    --screen-h: 460px;    /* lite lägre än tidigare (480) => garanterad scroll-delta */
    --radius-phone: 28px;
    --radius-screen: 20px;
  }

  * { box-sizing: border-box; }
  html, body { margin:0; padding:0; height:auto; }
  body{ background:transparent; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

  #stage{ display:inline-block; margin:0; padding:0; }

  .phone{
    position:relative; width:var(--phone-w); height:var(--phone-h);
    background:#fff; border-radius: var(--radius-phone);
    box-shadow: inset 0 0 0 1px #e0e0e0; overflow:hidden;
  }
  .notch{
    position:absolute; top:6px; left:50%; transform:translateX(-50%);
    width:90px; height:14px; background:#eee; border-radius:0 0 8px 8px;
    box-shadow: inset 0 0 2px rgba(0,0,0,.12); z-index:2;
  }
  .screen{
    position:absolute; top:var(--screen-top); left:var(--screen-lr);
    width:calc(var(--phone-w) - var(--screen-lr)*2); height:var(--screen-h);
    border-radius:var(--radius-screen); overflow:hidden; background:#fff;
    box-shadow: inset 0 0 18px rgba(0,0,0,.10);
    touch-action:none; cursor:grab; user-select:none; -webkit-user-select:none;
  }
  .screen.dragging{ cursor:grabbing; }
  .longshot{
    width:100%; height:auto; display:block;
    transform:translateY(0); opacity:1;
    will-change: transform, opacity;
    user-select:none; -webkit-user-drag:none; pointer-events:none;
  }

  @media (prefers-reduced-motion: reduce) {
    .longshot { transition: none !important; }
  }
</style>
</head>
<body>
  <div id="stage">
    <div class="phone" role="region" aria-label="Telefonram med förhandsvisning">
      <div class="notch"></div>
      <div class="screen" id="screen" tabindex="0" aria-label="Skärmområde med rullbar förhandsvisning">
        <img id="longshot" class="longshot"
             src="https://sleo1.github.io/scroll-demo/startsida2024-2.jpg"
             alt="Förhandsvisning av lång sida">
      </div>
    </div>
  </div>

<script>
(() => {
  // === Konfig ===
  const CONFIG = {
    STEP_DURATION: 4000,
    STEP_GAP:      200,
    TOP_PAUSE:     600,
    BOTTOM_PAUSE:  600,
    FADE_OUT_DUR:  500,
    FADE_IN_DUR:   350,
    RESUME_DELAY:  1500,
    WHEEL_SPEED:   1.0
  };

  const img    = document.getElementById('longshot');
  const screen = document.getElementById('screen');
  const stage  = document.getElementById('stage');

  // ---- Overrides via URL ----
  const qs = new URLSearchParams(location.search);
  const FORCE_AUTO = qs.get('auto');     // '1' (på), '0' (av), null = följ PRM
  const IGNORE_PRM = qs.get('prm') === '0';

  let running = false;
  let pausedByUser = false;
  let autoEnabled  = true;
  let resumeTimer  = null;

  const prm = window.matchMedia?.('(prefers-reduced-motion: reduce)').matches;
  if (prm && !IGNORE_PRM && FORCE_AUTO!=='1') autoEnabled = false;
  if (FORCE_AUTO==='0') autoEnabled = false;
  if (FORCE_AUTO==='1') autoEnabled = true;

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const setY  = (y)=>{ img.style.transform = `translateY(${-Math.max(0, Math.round(y))}px)`; };
  const transition = (props, dur, easing='ease') => { img.style.transition = props.map(p=>`${p} ${dur}ms ${easing}`).join(', '); };
  const clearTransition = ()=>{ img.style.transition = 'none'; };

  function deltaPx(){
    if(!img.naturalWidth || !img.naturalHeight) return 0;
    const scale = screen.clientWidth / img.naturalWidth;
    const imgH  = img.naturalHeight * scale;
    return Math.max(0, imgH - screen.clientHeight);
  }
  function currentY(){
    const m = /translateY\((-?\d+)px\)/.exec(img.style.transform);
    return m ? Math.max(0, -parseInt(m[1],10)) : 0;
  }
  function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

  function tempPauseAuto(){
    pausedByUser = true;
    clearTransition();
    if(resumeTimer) clearTimeout(resumeTimer);
    resumeTimer = setTimeout(()=>{ pausedByUser = false; }, CONFIG.RESUME_DELAY);
  }

  async function animateStep(fromY, toY){
    clearTransition(); setY(fromY); await sleep(20);
    transition(['transform'], CONFIG.STEP_DURATION, 'ease-in-out');
    setY(toY); await sleep(CONFIG.STEP_DURATION); clearTransition(); postExactHeight();
  }
  async function fadeReset(){
    clearTransition(); await sleep(20);
    transition(['opacity'], CONFIG.FADE_OUT_DUR, 'ease'); img.style.opacity = '0';
    await sleep(CONFIG.FADE_OUT_DUR);
    clearTransition(); setY(0); await sleep(20);
    transition(['opacity'], CONFIG.FADE_IN_DUR, 'ease'); img.style.opacity = '1';
    await sleep(CONFIG.FADE_IN_DUR); clearTransition(); postExactHeight();
  }

  async function loop(){
    if(running) return; running = true;
    while(running){
      const d = deltaPx();
      if(d <= 0){ img.style.opacity='1'; setY(0); await sleep(800); postExactHeight(); continue; }

      while(!(autoEnabled && !pausedByUser)) { await sleep(120); }

      const stepSize = Math.max(120, screen.clientHeight * 0.85);
      let pos = currentY();

      await sleep(CONFIG.TOP_PAUSE);
      while(pos < d - 1){
        if(!(autoEnabled && !pausedByUser)) break;
        const next = Math.min(d, pos + stepSize);
        await animateStep(pos, next);
        pos = next;
        await sleep(CONFIG.STEP_GAP);
      }
      if(!(autoEnabled && !pausedByUser)) continue;

      await sleep(CONFIG.BOTTOM_PAUSE);
      await fadeReset();
    }
  }

  // Manuell kontroll
  (function enableManual(){
    let dragging = false, startY = 0, startPos = 0;

    function startDrag(clientY, pointerId){
      tempPauseAuto();
      dragging = true; screen.classList.add('dragging');
      startY = clientY; startPos = currentY();
      try { if(pointerId != null && screen.setPointerCapture) screen.setPointerCapture(pointerId); } catch(e){}
    }
    function moveDrag(clientY){
      if(!dragging) return;
      const d = deltaPx(), dy = clientY - startY;
      const ny = clamp(startPos - dy, 0, d);
      clearTransition(); setY(ny);
    }
    function endDrag(){
      dragging = false; screen.classList.remove('dragging');
      try { if(screen.releasePointerCapture) screen.releasePointerCapture(); } catch(e){}
    }

    // Touch
    screen.addEventListener('touchstart', e=>{ if(e.touches.length){ startDrag(e.touches[0].clientY, null); } e.preventDefault(); }, {passive:false});
    screen.addEventListener('touchmove',  e=>{ if(e.touches.length){ moveDrag(e.touches[0].clientY); } e.preventDefault(); }, {passive:false});
    screen.addEventListener('touchend',   endDrag);

    // Pointer
    screen.addEventListener('pointerdown', e=>{ startDrag(e.clientY, e.pointerId); e.preventDefault(); });
    window.addEventListener('pointermove', e=>{ if(dragging) moveDrag(e.clientY); });
    window.addEventListener('pointerup',   endDrag);

    // Mouse fallback
    screen.addEventListener('mousedown', e=>{ if(e.button!==0) return; startDrag(e.clientY, null); e.preventDefault(); });
    window.addEventListener('mousemove', e=>{ if(dragging) moveDrag(e.clientY); });
    window.addEventListener('mouseup',   endDrag);

    // Wheel
    screen.addEventListener('wheel', e=>{
      tempPauseAuto();
      const d = deltaPx(), y = currentY();
      const ny = clamp(y + e.deltaY * CONFIG.WHEEL_SPEED, 0, d);
      clearTransition(); setY(ny);
      e.preventDefault();
    }, {passive:false});

    // Keyboard
    screen.addEventListener('keydown', e=>{
      const d = deltaPx(); if(!d) return;
      const y = currentY();
      const pageStep = screen.clientHeight * 0.85;
      if (e.key==='ArrowDown' || e.key==='PageDown') { tempPauseAuto(); setY(Math.min(d, y + (e.key==='PageDown'?pageStep:60))); e.preventDefault(); }
      if (e.key==='ArrowUp'   || e.key==='PageUp')   { tempPauseAuto(); setY(Math.max(0, y - (e.key==='PageUp'?pageStep:60))); e.preventDefault(); }
      if (e.key==='Home') { tempPauseAuto(); setY(0); e.preventDefault(); }
      if (e.key==='End')  { tempPauseAuto(); setY(d); e.preventDefault(); }
    });
  })();

  async function ready(){
    try{ if(img.decode) await img.decode(); }catch(e){}
    img.style.opacity='1'; setY(0); postExactHeight(); loop();
  }
  if (img.complete && img.naturalWidth) ready();
  else img.addEventListener('load', ready, { once:true });

  // Auto-höjd -> Google Sites (exakt höjd på #stage)
  function postExactHeight(){
    const h = Math.ceil(document.getElementById('stage').getBoundingClientRect().height);
    parent.postMessage({ scrollDemoHeight: h }, "*");
  }
  window.addEventListener("load", postExactHeight);
  window.addEventListener("resize", postExactHeight);
  if ('ResizeObserver' in window) {
    new ResizeObserver(()=>postExactHeight()).observe(stage);
  } else {
    setInterval(postExactHeight, 1200);
  }

  // Watchdog: om autoscroll av misstag inte startar inom 6s men ska vara på → starta
  setTimeout(()=>{ 
    if (deltaPx()>0 && (FORCE_AUTO==='1' || (!prm || IGNORE_PRM)) ) {
      autoEnabled = true;
    }
  }, 6000);
})();
</script>
</body>
</html>
