<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Screen-only autoscroll</title>
<style>
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;overscroll-behavior:none;background:transparent}
  /* Fyll hela iframen */
  .viewport{
    position:fixed; inset:0;
    overflow:hidden; background:#fff; /* vit “skärm” */
    touch-action:none; cursor:grab; user-select:none; -webkit-user-select:none;
  }
  .viewport.dragging{ cursor:grabbing; }
  img.longshot{
    width:100%; height:auto; display:block;
    transform:translateY(0); will-change:transform,opacity; opacity:1;
    user-select:none; -webkit-user-drag:none; pointer-events:none;
  }
  ::-webkit-scrollbar{width:0;height:0}
</style>
</head>
<body>
  <div class="viewport" id="vp" tabindex="0" aria-label="Rullbar förhandsvisning">
    <img id="longshot" class="longshot"
         src="https://sleo1.github.io/scroll-demo/startsida2024-2.jpg"
         alt="Lång sida">
  </div>

<script>
(()=> {
  const CONFIG={STEP_DURATION:4000,STEP_GAP:200,TOP_PAUSE:600,BOTTOM_PAUSE:600,FADE_OUT_DUR:500,FADE_IN_DUR:350,RESUME_DELAY:1500,WHEEL_SPEED:1.0};
  const vp=document.getElementById('vp'), img=document.getElementById('longshot');
  let running=false, paused=false, tResume=null;

  const sleep=ms=>new Promise(r=>setTimeout(r,ms));
  const setY=y=>img.style.transform=`translateY(${-Math.max(0,Math.round(y))}px)`;
  const trans=(props,dur,e='ease')=>img.style.transition=props.map(p=>`${p} ${dur}ms ${e}`).join(', ');
  const clear=()=>img.style.transition='none';
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const curY=()=>{const m=/translateY\((-?\d+)px\)/.exec(img.style.transform);return m?Math.max(0,-parseInt(m[1],10)):0};
  function delta(){ if(!img.naturalWidth||!img.naturalHeight) return 0;
    const scale=vp.clientWidth/img.naturalWidth;
    const h=img.naturalHeight*scale;
    return Math.max(0,h - vp.clientHeight);
  }
  function tempPause(){ paused=true; clear(); if(tResume)clearTimeout(tResume); tResume=setTimeout(()=>paused=false, CONFIG.RESUME_DELAY); }

  async function step(from,to){ clear(); setY(from); await sleep(20); trans(['transform'],CONFIG.STEP_DURATION,'ease-in-out'); setY(to); await sleep(CONFIG.STEP_DURATION); clear(); postSize(); }
  async function fadeReset(){ clear(); await sleep(20); trans(['opacity'],CONFIG.FADE_OUT_DUR); img.style.opacity='0';
    await sleep(CONFIG.FADE_OUT_DUR); clear(); setY(0); await sleep(20); trans(['opacity'],CONFIG.FADE_IN_DUR); img.style.opacity='1'; await sleep(CONFIG.FADE_IN_DUR); clear(); postSize(); }

  async function loop(){ if(running) return; running=true;
    while(running){ const d=delta(); if(d<=0){ img.style.opacity='1'; setY(0); await sleep(800); postSize(); continue; }
      while(paused){ await sleep(100); }
      const stride=Math.max(120, vp.clientHeight*0.85); let y=curY();
      await sleep(CONFIG.TOP_PAUSE);
      while(y<d-1){ if(paused) break; const n=Math.min(d,y+stride); await step(y,n); y=n; await sleep(CONFIG.STEP_GAP); }
      if(paused) continue;
      await sleep(CONFIG.BOTTOM_PAUSE); await fadeReset();
    }
  }

  // Manuell control (touch/pointer/mouse/wheel/keys)
  ;(()=>{let dragging=false,startY=0,startPos=0;
    function startDrag(cy,id){ tempPause(); dragging=true; vp.classList.add('dragging'); startY=cy; startPos=curY(); try{ if(id!=null && vp.setPointerCapture) vp.setPointerCapture(id);}catch(e){} }
    function moveDrag(cy){ if(!dragging) return; const d=delta(),ny=clamp(startPos-(cy-startY),0,d); clear(); setY(ny); }
    function endDrag(){ dragging=false; vp.classList.remove('dragging'); try{ if(vp.releasePointerCapture) vp.releasePointerCapture(); }catch(e){} }
    vp.addEventListener('touchstart',e=>{ if(e.touches.length) startDrag(e.touches[0].clientY,null); e.preventDefault(); },{passive:false});
    vp.addEventListener('touchmove', e=>{ if(e.touches.length) moveDrag(e.touches[0].clientY); e.preventDefault(); },{passive:false});
    vp.addEventListener('touchend', endDrag);
    vp.addEventListener('pointerdown', e=>{ startDrag(e.clientY,e.pointerId); e.preventDefault(); });
    window.addEventListener('pointermove', e=>{ if(dragging) moveDrag(e.clientY); });
    window.addEventListener('pointerup', endDrag);
    vp.addEventListener('mousedown', e=>{ if(e.button!==0) return; startDrag(e.clientY,null); e.preventDefault(); });
    window.addEventListener('mousemove', e=>{ if(dragging) moveDrag(e.clientY); });
    window.addEventListener('mouseup', endDrag);
    vp.addEventListener('wheel', e=>{ tempPause(); const d=delta(),ny=clamp(curY()+e.deltaY*CONFIG.WHEEL_SPEED,0,d); clear(); setY(ny); e.preventDefault(); },{passive:false});
    vp.addEventListener('keydown', e=>{ const d=delta(); if(!d) return; const y=curY(), page=vp.clientHeight*0.85;
      if(e.key==='ArrowDown'||e.key==='PageDown'){ tempPause(); setY(Math.min(d,y+(e.key==='PageDown'?page:60))); e.preventDefault(); }
      if(e.key==='ArrowUp'  ||e.key==='PageUp'){   tempPause(); setY(Math.max(0,y-(e.key==='PageUp'?page:60))); e.preventDefault(); }
      if(e.key==='Home'){ tempPause(); setY(0); e.preventDefault(); }
      if(e.key==='End'){  tempPause(); setY(d); e.preventDefault(); }
    });
  })();

  function postSize(){ try{ parent.postMessage({ scrollDemoHeight: document.documentElement.scrollHeight }, "*"); }catch(e){} }
  window.addEventListener('load', async ()=>{ try{ if(img.decode) await img.decode(); }catch(e){} img.style.opacity='1'; setY(0); postSize(); loop(); });
  window.addEventListener('resize', postSize);
  if('ResizeObserver' in window){ new ResizeObserver(()=>postSize()).observe(document.documentElement); } else { setInterval(postSize,1500); }
})();
</script>
</body>
</html>
